\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[brazilian]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\title{Dropbox - Parte I}
\author{Augusto Bennemann, Fabrício Martins Mazzola e Txai Wieser}

\begin{document}
\maketitle

\begin{abstract}
Your abstract.
\end{abstract}

\section{Ambiente de desenvolvimento e teste}

O projeto foi desenvolvido utilizando um ambiente com as seguintes caracteristicas:
\begin{itemize}
	\item Configuração da máquina:
	\begin{itemize}
		\item Processador(es):
		\item Memória:
	\end{itemize}

	\item{Sistema operacional}: 
	\begin{itemize}
		\item Distribuição:
		\item Versão:
	\end{itemize}

	\item Software suporte:
	\begin{itemize}
		\item Compiladores (versões):
	\end{itemize}
\end{itemize}

\section{Descrições e justificativas}

\subsection{Funcionamento}

A aplicação do cliente possui 3 threads, a primeira é o 'shell', que fica espera comandos através da CLI.
A segunda thread fica aguardando notificações do sistema de arquivos, através da biblioteca 'inotify', pra monitorar as modificações de arquivos no diretório 'sync\_dir' do usuário. Quando o arquivo é criado ou renomeado, faz o upload pro servidor. E quando o arquivo é deletado, envia um comando de DELETE pro servidor.
A terceira thread é a local\_server, que fica ouvindo chamadas de PUSH e DELETE do servidor.

O servidor possui uma thread principal que é responsável por lidar com as requisições de conexões dos clientes. Para cada cliente (por dispositivo) que realiza a conexão é criada uma thread. Essa thread fica aguardando as requisições do cliente. Quando um arquivo é recebido pelos servidor ele propaga as alterações pros outros dispositivos conectados, enviando mensagens de PUSH e DELETE.

Foi implementado no client uma lista de arquivos ignorados. Essa lista mantém os arquivos que devem ser ignorados na próxima vez que o 'inotify' perceber que eles foram alterados. Os arquivos são incluídos nessa lista quando o cliente recebe um PUSH do servidor e faz download de um arquivo, e quando recebe um DELETE do servidor e o deleta. Assim, quando o 'inofity' é executado e recebe a informação esses arquivos  foram modificados/removidos, podemos ignorar e evitar mandar um UPLOAD/DELETE para o servidor. Após essa detecção é feita a remoção do arquivo da lista.

\subsection{Concorrência no servidor}

\subsection{Sincronização}

No cliente utilizamos dois mutex, o 'fileOperationMutex' serve para garantir que somente uma operação de arquivo seja feita por vez, e o 'inotifyMutex' serve para garantir que o 'inotify' não seja ativado antes que um arquivo seja 'incluído' na lista de arquivos ignorados.

Já no servidor, utilizamos somente um mutex (armazenado na struct do usuário) para garantir que algumas coisas, como por exemplo a conexão inicial no servidor, sejam executadas em somente um dispositivo por vez.

Além de proteção de seções críticas, implementamos algumas barreiras, para realizar a sincronização de tarefas do cliente.

Temos duas barreiras no cliente, a primeira é a 'syncbarrier', garante que o 'shell' do dropbox só apareça depois que for feita uma conexão com sucesso ao servidor. Assim, a thread principal de interação com o usuário fica travada até a conexão, mostrando uma mensagem de sincronia "syncing..." até que a sincronização tenha sido completada.
A segunda barreira no cliente é a 'localserverbarrier', que garante que a sincronização inicial de arquivos só será feito após o local\_server estar disponível para aceitar conexões.

\subsection{Comunicação}

\subsection{Estruturas e funções adicionais}

\subsubsection{dropboxUtil}
\begin{itemize}
	\item void makedir\_if\_not\_exists(const char* path)
	\newline Verifica se o diretório especificado no parâmetro `path` existe e caso contrario o cria.
	
	\item int file\_exists(const char* path)
	\newline Verifica se o diretório especificado no parâmetro `path` existe.

	\item int connect\_server(char * host, int port)
	\newline Abre uma conexão via socket com o `host`.
\end{itemize}


\subsubsection{dropboxServer}
\begin{itemize}
	\item struct file\_info
	\newline Foram feitas duas mudanças na estrutura 'client', a primeira foi a remoção da propriedade 'char extension[MAXNAME]' para evitar duplicações ja que a extensão ja é facilmente recuperada através de 'char name[MAXNAME]'. A outra modificação foi o uso de uma estrutura 'time\_t' ao invés de um 'char *' para a propriedade 'last\_modified'.
	
	\item struct client
	\newline Na estrutura 'client' foram adicionadas duas propriedades, a primeira é a 'int devices\_server[MAXDEVICES]' que armazena sockets 'servidor' do cliente (que recebe requisições de PUSH e DELETE), 'pthread\_mutex\_t mutex' foi adicionado e é o mutex que protege as seções críticas de cada cliente.
	
	\item struct tailq\_entry
	\newline Estrutura usada na lista de clientes.
	
	\item void delete\_file(char *file)
	\newline Remove o arquivo file para do servidor. 'file' – filename.ext
	
	\item void *connection\_handler(void *socket\_desc)
	\newline Trata as conexões para cada cliente.

\end{itemize}


\subsubsection{dropboxClient}
\begin{itemize}
	\item struct tailq\_entry
	\newline Estrutura usada na lista de clientes.
	
	\item void delete\_server\_file(char *file)
	\newline Remove o arquivo file para do servidor. 'file' – filename.ext
\end{itemize}

\subsubsection{SIGNAL}
Ao terminar o processo do servidor (usando CTRL+C, por exemplo), recebemos a notificação do signal enviado (SIGINT) e então realizamos a saída de modo 'gracefully'. Isso faz com que a conexão seja fechada na hora, e assim o cliente percebe e encerra também, com uma mensagem de erro "servidor desconectou, saindo...".

\subsection{Testes}

\section{Dificuldades encontradas}
 
\bibliographystyle{alpha}
\bibliography{sample}

\end{document}